import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { 
  SupportedLanguage, 
  LanguageContextType, 
  defaultLanguage, 
  supportedLanguages 
} from '@/types';
import en from '@/locales/en';
import nl from '@/locales/nl';
import de from '@/locales/de';
import es from '@/locales/es';
import fr from '@/locales/fr';

// All locale data
const locales = {
  en,
  nl,
  de,
  es,
  fr
};

// Create the context
const LanguageContext = createContext<LanguageContextType>({
  language: defaultLanguage,
  setLanguage: () => {},
  t: (key: string) => key,
  languages: supportedLanguages
});

interface LanguageProviderProps {
  children: ReactNode;
}

export const LanguageProvider: React.FC<LanguageProviderProps> = ({ children }) => {
  // Initialize with the user's preferred language or the default
  const [language, setLanguageState] = useState<SupportedLanguage>(() => {
    // Try to get the language from localStorage
    const savedLang = localStorage.getItem('language');
    if (savedLang && Object.keys(supportedLanguages).includes(savedLang)) {
      return savedLang as SupportedLanguage;
    }
    
    // Otherwise detect browser language
    try {
      const browserLang = navigator.language.split('-')[0];
      if (Object.keys(supportedLanguages).includes(browserLang)) {
        return browserLang as SupportedLanguage;
      }
    } catch (error) {
      console.warn('Error detecting browser language:', error);
    }
    
    return defaultLanguage;
  });

  // Function to change the language
  const setLanguage = (lang: SupportedLanguage) => {
    if (Object.keys(supportedLanguages).includes(lang)) {
      setLanguageState(lang);
      localStorage.setItem('language', lang);
    } else {
      console.warn(`Language "${lang}" not supported`);
    }
  };

  // Translation function that handles nested paths with fallbacks
  const t = (key: string): string => {
    // Default empty response if key is invalid
    if (!key || typeof key !== 'string') {
      return '';
    }
    
    try {
      // Split the key into parts (e.g., "nav.features" -> ["nav", "features"])
      const keyParts = key.split('.');
      let translation;
      
      // Try to get translation from current language
      let obj = locales[language];
      for (const part of keyParts) {
        if (!obj || typeof obj !== 'object') {
          obj = undefined;
          break;
        }
        obj = obj[part];
      }
      translation = obj;
      
      // If translation found, return it
      if (translation !== undefined && translation !== null) {
        return String(translation);
      }
      
      // If not found, try with default language
      if (language !== defaultLanguage) {
        obj = locales[defaultLanguage];
        for (const part of keyParts) {
          if (!obj || typeof obj !== 'object') {
            obj = undefined;
            break;
          }
          obj = obj[part];
        }
        translation = obj;
        
        if (translation !== undefined && translation !== null) {
          return String(translation);
        }
      }
      
      // If we're still here, translation wasn't found
      console.warn(`No translation found for key: ${key}`);
      
      // Return the key itself as fallback
      return key;
    } catch (error) {
      console.error(`Error retrieving translation for key "${key}":`, error);
      return key;
    }
  };

  // Update document language attribute when language changes
  useEffect(() => {
    document.documentElement.lang = language;
  }, [language]);

  const value = {
    language,
    setLanguage,
    t,
    languages: supportedLanguages
  };

  return (
    <LanguageContext.Provider value={value}>
      {children}
    </LanguageContext.Provider>
  );
};

// Custom hook to use the language context
export const useLanguage = () => {
  const context = useContext(LanguageContext);
  
  if (context === undefined) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  
  return context;
};